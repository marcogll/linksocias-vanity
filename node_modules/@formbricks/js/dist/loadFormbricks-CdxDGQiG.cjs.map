{"version":3,"file":"loadFormbricks-CdxDGQiG.cjs","sources":["../src/shared/loadFormbricks.ts","../src/methodQueue.ts","../../types/errorHandlers.ts"],"sourcesContent":["import { Result, wrapThrowsAsync } from \"../../../types/errorHandlers\";\nimport { MethodQueue } from \"../methodQueue\";\n\nlet isInitializing = false;\nlet isInitialized = false;\nconst methodQueue = new MethodQueue();\n\n// Load the SDK, return the result\nconst loadFormbricksSDK = async (apiHost: string, sdkType: \"app\" | \"website\"): Promise<Result<void>> => {\n  if (!window.formbricks) {\n    const res = await fetch(`${apiHost}/api/packages/${sdkType}`);\n\n    // Failed to fetch the app package\n    if (!res.ok) {\n      return { ok: false, error: new Error(`Failed to load Formbricks ${sdkType} SDK`) };\n    }\n\n    const sdkScript = await res.text();\n    const scriptTag = document.createElement(\"script\");\n    scriptTag.innerHTML = sdkScript;\n    document.head.appendChild(scriptTag);\n\n    const getFormbricks = async () =>\n      new Promise<void>((resolve, reject) => {\n        const checkInterval = setInterval(() => {\n          if (window.formbricks) {\n            clearInterval(checkInterval);\n            resolve();\n          }\n        }, 100);\n\n        setTimeout(() => {\n          clearInterval(checkInterval);\n          reject(new Error(`Formbricks ${sdkType} SDK loading timed out`));\n        }, 10000);\n      });\n\n    try {\n      await getFormbricks();\n      return { ok: true, data: undefined };\n    } catch (error: any) {\n      return {\n        ok: false,\n        error: new Error(error.message ?? `Failed to load Formbricks ${sdkType} SDK`),\n      };\n    }\n  }\n\n  return { ok: true, data: undefined };\n};\n\n// TODO: @pandeymangg - Fix these types\n// type FormbricksAppMethods = {\n//   [K in keyof TFormbricksApp]: TFormbricksApp[K] extends Function ? K : never;\n// }[keyof TFormbricksApp];\n\n// type FormbricksWebsiteMethods = {\n//   [K in keyof TFormbricksWebsite]: TFormbricksWebsite[K] extends Function ? K : never;\n// }[keyof TFormbricksWebsite];\n\nexport const loadFormbricksToProxy = async (prop: string, sdkType: \"app\" | \"website\", ...args: any[]) => {\n  const executeMethod = async () => {\n    try {\n      //  @ts-expect-error\n      return await (window.formbricks[prop] as Function)(...args);\n    } catch (error) {\n      console.error(`ðŸ§± Formbricks - Global error: ${error}`);\n      throw error;\n    }\n  };\n\n  if (!isInitialized) {\n    if (isInitializing) {\n      methodQueue.add(executeMethod);\n    } else {\n      if (prop === \"init\") {\n        isInitializing = true;\n\n        const initialize = async () => {\n          const { apiHost } = args[0];\n          const loadSDKResult = await wrapThrowsAsync(loadFormbricksSDK)(apiHost, sdkType);\n\n          if (!loadSDKResult.ok) {\n            isInitializing = false;\n            console.error(`ðŸ§± Formbricks - Global error: ${loadSDKResult.error.message}`);\n            return;\n          }\n\n          try {\n            const result = await (window.formbricks[prop] as Function)(...args);\n            isInitialized = true;\n            isInitializing = false;\n\n            return result;\n          } catch (error) {\n            isInitializing = false;\n            console.error(`ðŸ§± Formbricks - Global error: ${error}`);\n            throw error;\n          }\n        };\n\n        methodQueue.add(initialize);\n      } else {\n        console.error(\n          \"ðŸ§± Formbricks - Global error: You need to call formbricks.init before calling any other method\"\n        );\n        return;\n      }\n    }\n  } else {\n    // @ts-expect-error\n    if (window.formbricks && typeof window.formbricks[prop] !== \"function\") {\n      console.error(\n        `ðŸ§± Formbricks - Global error: Formbricks ${sdkType} SDK does not support method ${String(prop)}`\n      );\n      return;\n    }\n\n    methodQueue.add(executeMethod);\n    return;\n  }\n};\n","// Simple queue for formbricks methods\n\nexport class MethodQueue {\n  private queue: (() => Promise<void>)[] = [];\n  private isExecuting = false;\n\n  add = (method: () => Promise<void>) => {\n    this.queue.push(method);\n    this.run();\n  };\n\n  private runNext = async () => {\n    if (this.isExecuting) return;\n\n    const method = this.queue.shift();\n    if (method) {\n      this.isExecuting = true;\n      try {\n        await method();\n      } finally {\n        this.isExecuting = false;\n        if (this.queue.length > 0) {\n          this.runNext();\n        }\n      }\n    }\n  };\n\n  run = async () => {\n    if (!this.isExecuting && this.queue.length > 0) {\n      await this.runNext();\n    }\n  };\n\n  clear = () => {\n    this.queue = [];\n  };\n}\n","export type Result<T, E = Error> = { ok: true; data: T } | { ok: false; error: E };\n\nexport const ok = <T, E>(data: T): Result<T, E> => ({ ok: true, data });\n\nexport const okVoid = <E>(): Result<void, E> => ({ ok: true, data: undefined });\n\nexport const err = <E = Error>(error: E): Result<never, E> => ({\n  ok: false,\n  error,\n});\n\n/**\n * Applies the given function `fn` to the data property of the input `result` object\n * and returns a new `Result` object with the transformed data property.\n *\n * @template T The type of the input data.\n * @template R The type of the output data.\n *\n * @param {function(value: T): R} fn The function to apply to the data property of the input `result` object.\n * @returns {function(result: Result<T>): Result<R>} A new function that takes in a `Result<T>` object and returns a new `Result<R>` object.\n *\n * @example\n * const divideByTwo = (num: number): Result<number> => {\n *   if (num === 0) {\n *     return { ok: false, error: \"Cannot divide zero\" };\n *   }\n *\n *   return { ok: true, data: num / 2 };\n * }\n *\n * const wrappedDivideByTwo = wrap(divideByTwo);\n *\n * const result1: Result<number> = { ok: true, data: 10 };\n * const result2: Result<number> = { ok: false, error: \"Invalid input\" };\n * const result3: Result<number> = { ok: true, data: 0 };\n *\n * console.log(wrappedDivideByTwo(result1)); // { ok: true, data: 5 }\n * console.log(wrappedDivideByTwo(result2)); // { ok: false, error: \"Invalid input\" }\n * console.log(wrappedDivideByTwo(result3)); // { ok: false, error: \"Cannot divide zero\" }\n */\n\nexport const wrap =\n  <T, R>(fn: (value: T) => R) =>\n  (result: Result<T>): Result<R> =>\n    result.ok === true ? { ok: true, data: fn(result.data) } : result;\n\n/**\n * Matches the given `result` object against its `ok` property and invokes the `onSuccess` function\n * if `ok` is `true`, or the `onError` function if `ok` is `false`. Returns the result of the invoked function. Match a Result object and run a function depending on the result.\n *\n * @template TSuccess - Type of the success value\n * @template TError - Type of the error value\n * @template TReturn - Type of the return value\n *\n * @param {Result<TSuccess, TError>} result The `Result` object to match against.\n * @param {(value: TSuccess) => TReturn} onSuccess The function to invoke if `result.ok` is `true`.\n * @param {(error: TError) => TReturn} onError The function to invoke if `result.ok` is `false`.\n *\n * @returns {TReturn} The result of the invoked function.\n *\n * @example\n * const test = (): Result<string, Error> => {\n *  return err(new Error(\"error happened\"));\n * }\n *\n * const result = test();\n *\n * match(result, (value) => {\n *  console.log(value); // never run with this example\n * }, (error) => {\n *  console.log(error); // Error: error happened\n * });\n */\nexport const match = <TSuccess, TError, TReturn>(\n  result: Result<TSuccess, TError>,\n  onSuccess: (value: TSuccess) => TReturn,\n  onError: (error: TError) => TReturn\n): TReturn => (result.ok === true ? onSuccess(result.data) : onError(result.error));\n\n/**\n * Wraps a function `fn` that may throw an error into a new function that returns a `Result` object.\n * If the wrapped function throws an error, the returned `Result` object will have an `ok` property of `false`\n * and an `error` property containing the thrown error. Otherwise, the returned `Result` object will have an\n * `ok` property of `true` and a `data` property containing the result of the wrapped function.\n *\n * @template T The type of the result value.\n * @template A An array of the types of the arguments expected by the wrapped function.\n *\n * @param {(...args: A) => T} fn The function to wrap.\n * @returns {(...args: A) => Result<T>} A new function that returns a `Result` object.\n *\n * @example\n * function divideByTwo(num: number): number {\n *   if (num === 0) {\n *     throw new Error(\"Cannot divide zero\");\n *   }\n *   return num / 2;\n * }\n *\n * const wrappedDivideByTwo = wrapThrows(divideByTwo);\n *\n * const result1: Result<number> = wrappedDivideByTwo(10); // { ok: true, data: 5 }\n * const result2: Result<number> = wrappedDivideByTwo(0); // { ok: false, error: Error(\"Cannot divide zero\") }\n */\nexport const wrapThrows =\n  <T, A extends any[]>(fn: (...args: A) => T): ((...args: A) => Result<T>) =>\n  (...args: A): Result<T> => {\n    try {\n      return {\n        ok: true,\n        data: fn(...args),\n      };\n    } catch (error: any) {\n      return {\n        ok: false,\n        error,\n      };\n    }\n  };\n\nexport const wrapThrowsAsync =\n  <T, A extends any[]>(fn: (...args: A) => Promise<T>) =>\n  async (...args: A): Promise<Result<T>> => {\n    try {\n      return {\n        ok: true,\n        data: await fn(...args),\n      };\n    } catch (error) {\n      return {\n        ok: false,\n        error: error as Error,\n      };\n    }\n  };\n"],"names":["isInitializing","isInitialized","methodQueue","constructor","this","queue","isExecuting","add","method","push","run","runNext","async","shift","length","clear","loadFormbricksSDK","apiHost","sdkType","window","formbricks","res","fetch","ok","error","Error","sdkScript","text","scriptTag","document","createElement","innerHTML","head","appendChild","getFormbricks","Promise","resolve","reject","checkInterval","setInterval","clearInterval","setTimeout","data","message","prop","args","executeMethod","console","String","initialize","loadSDKResult","fn","result"],"mappings":"aAGA,IAAIA,GAAiB,EACjBC,GAAgB,EACpB,MAAMC,EAAc,ICHb,MAAA,WAAAC,GACLC,KAAQC,MAAiC,GACzCD,KAAQE,aAAc,EAEtBF,KAAAG,IAAOC,IACAJ,KAAAC,MAAMI,KAAKD,GAChBJ,KAAKM,KAAI,EAGXN,KAAQO,QAAUC,UAChB,GAAIR,KAAKE,YAAa,OAEhB,MAAAE,EAASJ,KAAKC,MAAMQ,QAC1B,GAAIL,EAAQ,CACVJ,KAAKE,aAAc,EACf,UACIE,GAAO,CACb,QACAJ,KAAKE,aAAc,EACfF,KAAKC,MAAMS,OAAS,GACtBV,KAAKO,SAET,CACF,GAGFP,KAAAM,IAAME,WACCR,KAAKE,aAAeF,KAAKC,MAAMS,OAAS,SACrCV,KAAKO,SACb,EAGFP,KAAAW,MAAQ,KACNX,KAAKC,MAAQ,GACf,GD5BIW,EAAoBJ,MAAOK,EAAiBC,KAC5C,IAACC,OAAOC,WAAY,CACtB,MAAMC,QAAYC,MAAM,GAAGL,kBAAwBC,KAG/C,IAACG,EAAIE,GACA,MAAA,CAAEA,IAAI,EAAOC,MAAO,IAAIC,MAAM,6BAA6BP,UAG9D,MAAAQ,QAAkBL,EAAIM,OACtBC,EAAYC,SAASC,cAAc,UACzCF,EAAUG,UAAYL,EACbG,SAAAG,KAAKC,YAAYL,GAE1B,MAAMM,EAAgBtB,SACpB,IAAIuB,SAAc,CAACC,EAASC,KACpB,MAAAC,EAAgBC,aAAY,KAC5BpB,OAAOC,aACToB,cAAcF,OAEhB,GACC,KAEHG,YAAW,KACTD,cAAcF,GACdD,EAAO,IAAIZ,MAAM,cAAcP,2BAAgC,GAC9D,IAAK,IAGR,IAEF,aADMgB,IACC,CAAEX,IAAI,EAAMmB,UAAM,SAClBlB,GACA,MAAA,CACLD,IAAI,EACJC,MAAO,IAAIC,MAAMD,EAAMmB,SAAW,6BAA6BzB,SAEnE,CACF,CAEA,MAAO,CAAEK,IAAI,EAAMmB,UAAM,EAAU,gCAYA9B,MAAOgC,EAAc1B,KAA+B2B,KACvF,MAAMC,EAAgBlC,UAChB,IAEF,aAAcO,OAAOC,WAAWwB,MAAsBC,SAC/CrB,GAED,MADEuB,QAAAvB,MAAM,iCAAiCA,KACzCA,CACR,GAGF,GAAKvB,EAwCH,OAAIkB,OAAOC,YAAiD,mBAA5BD,OAAOC,WAAWwB,QACxCG,QAAAvB,MACN,4CAA4CN,iCAAuC8B,OAAOJ,WAK9F1C,EAAYK,IAAIuC,GA9ChB,GAAI9C,EACFE,EAAYK,IAAIuC,OACX,CACL,GAAa,SAATF,EA+BF,YAHQG,QAAAvB,MACN,kGA7BiB,CACFxB,GAAA,EAEjB,MAAMiD,EAAarC,UACjB,MAAMK,QAAEA,GAAY4B,EAAK,GACnBK,QEyCOC,EFzC+BnC,EE0CpDJ,SAAUiC,KACJ,IACK,MAAA,CACLtB,IAAI,EACJmB,WAAYS,KAAMN,UAEbrB,GACA,MAAA,CACLD,IAAI,EACJC,QAEJ,IFrDqEP,EAASC,GEyChF,IAAqBiC,EFvCT,IAACD,EAAc3B,GAGjB,OAFiBvB,GAAA,OACjB+C,QAAQvB,MAAM,iCAAiC0B,EAAc1B,MAAMmB,WAIjE,IACF,MAAMS,QAAgBjC,OAAOC,WAAWwB,MAAsBC,GAIvD,OAHS5C,GAAA,EACCD,GAAA,EAEVoD,QACA5B,GAGD,MAFWxB,GAAA,EACT+C,QAAAvB,MAAM,iCAAiCA,KACzCA,CACR,GAGFtB,EAAYK,IAAI0C,EAAU,CAO9B,CAYF"}