const wrapThrowsAsync = (fn) => async (...args) => {
  try {
    return {
      ok: true,
      data: await fn(...args)
    };
  } catch (error) {
    return {
      ok: false,
      error
    };
  }
};
class MethodQueue {
  constructor() {
    this.queue = [];
    this.isExecuting = false;
    this.add = (method) => {
      this.queue.push(method);
      this.run();
    };
    this.runNext = async () => {
      if (this.isExecuting)
        return;
      const method = this.queue.shift();
      if (method) {
        this.isExecuting = true;
        try {
          await method();
        } finally {
          this.isExecuting = false;
          if (this.queue.length > 0) {
            this.runNext();
          }
        }
      }
    };
    this.run = async () => {
      if (!this.isExecuting && this.queue.length > 0) {
        await this.runNext();
      }
    };
    this.clear = () => {
      this.queue = [];
    };
  }
}
let isInitializing = false;
let isInitialized = false;
const methodQueue = new MethodQueue();
const loadFormbricksSDK = async (apiHost, sdkType) => {
  if (!window.formbricks) {
    const res = await fetch(`${apiHost}/api/packages/${sdkType}`);
    if (!res.ok) {
      return { ok: false, error: new Error(`Failed to load Formbricks ${sdkType} SDK`) };
    }
    const sdkScript = await res.text();
    const scriptTag = document.createElement("script");
    scriptTag.innerHTML = sdkScript;
    document.head.appendChild(scriptTag);
    const getFormbricks = async () => new Promise((resolve, reject) => {
      const checkInterval = setInterval(() => {
        if (window.formbricks) {
          clearInterval(checkInterval);
          resolve();
        }
      }, 100);
      setTimeout(() => {
        clearInterval(checkInterval);
        reject(new Error(`Formbricks ${sdkType} SDK loading timed out`));
      }, 1e4);
    });
    try {
      await getFormbricks();
      return { ok: true, data: void 0 };
    } catch (error) {
      return {
        ok: false,
        error: new Error(error.message ?? `Failed to load Formbricks ${sdkType} SDK`)
      };
    }
  }
  return { ok: true, data: void 0 };
};
const loadFormbricksToProxy = async (prop, sdkType, ...args) => {
  const executeMethod = async () => {
    try {
      return await window.formbricks[prop](...args);
    } catch (error) {
      console.error(`ðŸ§± Formbricks - Global error: ${error}`);
      throw error;
    }
  };
  if (!isInitialized) {
    if (isInitializing) {
      methodQueue.add(executeMethod);
    } else {
      if (prop === "init") {
        isInitializing = true;
        const initialize = async () => {
          const { apiHost } = args[0];
          const loadSDKResult = await wrapThrowsAsync(loadFormbricksSDK)(apiHost, sdkType);
          if (!loadSDKResult.ok) {
            isInitializing = false;
            console.error(`ðŸ§± Formbricks - Global error: ${loadSDKResult.error.message}`);
            return;
          }
          try {
            const result = await window.formbricks[prop](...args);
            isInitialized = true;
            isInitializing = false;
            return result;
          } catch (error) {
            isInitializing = false;
            console.error(`ðŸ§± Formbricks - Global error: ${error}`);
            throw error;
          }
        };
        methodQueue.add(initialize);
      } else {
        console.error(
          "ðŸ§± Formbricks - Global error: You need to call formbricks.init before calling any other method"
        );
        return;
      }
    }
  } else {
    if (window.formbricks && typeof window.formbricks[prop] !== "function") {
      console.error(
        `ðŸ§± Formbricks - Global error: Formbricks ${sdkType} SDK does not support method ${String(prop)}`
      );
      return;
    }
    methodQueue.add(executeMethod);
    return;
  }
};
export {
  loadFormbricksToProxy as l
};
//# sourceMappingURL=loadFormbricks-BzaImH2L.js.map
