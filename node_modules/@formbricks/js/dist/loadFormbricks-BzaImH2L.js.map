{"version":3,"file":"loadFormbricks-BzaImH2L.js","sources":["../../types/errorHandlers.ts","../src/methodQueue.ts","../src/shared/loadFormbricks.ts"],"sourcesContent":["export type Result<T, E = Error> = { ok: true; data: T } | { ok: false; error: E };\n\nexport const ok = <T, E>(data: T): Result<T, E> => ({ ok: true, data });\n\nexport const okVoid = <E>(): Result<void, E> => ({ ok: true, data: undefined });\n\nexport const err = <E = Error>(error: E): Result<never, E> => ({\n  ok: false,\n  error,\n});\n\n/**\n * Applies the given function `fn` to the data property of the input `result` object\n * and returns a new `Result` object with the transformed data property.\n *\n * @template T The type of the input data.\n * @template R The type of the output data.\n *\n * @param {function(value: T): R} fn The function to apply to the data property of the input `result` object.\n * @returns {function(result: Result<T>): Result<R>} A new function that takes in a `Result<T>` object and returns a new `Result<R>` object.\n *\n * @example\n * const divideByTwo = (num: number): Result<number> => {\n *   if (num === 0) {\n *     return { ok: false, error: \"Cannot divide zero\" };\n *   }\n *\n *   return { ok: true, data: num / 2 };\n * }\n *\n * const wrappedDivideByTwo = wrap(divideByTwo);\n *\n * const result1: Result<number> = { ok: true, data: 10 };\n * const result2: Result<number> = { ok: false, error: \"Invalid input\" };\n * const result3: Result<number> = { ok: true, data: 0 };\n *\n * console.log(wrappedDivideByTwo(result1)); // { ok: true, data: 5 }\n * console.log(wrappedDivideByTwo(result2)); // { ok: false, error: \"Invalid input\" }\n * console.log(wrappedDivideByTwo(result3)); // { ok: false, error: \"Cannot divide zero\" }\n */\n\nexport const wrap =\n  <T, R>(fn: (value: T) => R) =>\n  (result: Result<T>): Result<R> =>\n    result.ok === true ? { ok: true, data: fn(result.data) } : result;\n\n/**\n * Matches the given `result` object against its `ok` property and invokes the `onSuccess` function\n * if `ok` is `true`, or the `onError` function if `ok` is `false`. Returns the result of the invoked function. Match a Result object and run a function depending on the result.\n *\n * @template TSuccess - Type of the success value\n * @template TError - Type of the error value\n * @template TReturn - Type of the return value\n *\n * @param {Result<TSuccess, TError>} result The `Result` object to match against.\n * @param {(value: TSuccess) => TReturn} onSuccess The function to invoke if `result.ok` is `true`.\n * @param {(error: TError) => TReturn} onError The function to invoke if `result.ok` is `false`.\n *\n * @returns {TReturn} The result of the invoked function.\n *\n * @example\n * const test = (): Result<string, Error> => {\n *  return err(new Error(\"error happened\"));\n * }\n *\n * const result = test();\n *\n * match(result, (value) => {\n *  console.log(value); // never run with this example\n * }, (error) => {\n *  console.log(error); // Error: error happened\n * });\n */\nexport const match = <TSuccess, TError, TReturn>(\n  result: Result<TSuccess, TError>,\n  onSuccess: (value: TSuccess) => TReturn,\n  onError: (error: TError) => TReturn\n): TReturn => (result.ok === true ? onSuccess(result.data) : onError(result.error));\n\n/**\n * Wraps a function `fn` that may throw an error into a new function that returns a `Result` object.\n * If the wrapped function throws an error, the returned `Result` object will have an `ok` property of `false`\n * and an `error` property containing the thrown error. Otherwise, the returned `Result` object will have an\n * `ok` property of `true` and a `data` property containing the result of the wrapped function.\n *\n * @template T The type of the result value.\n * @template A An array of the types of the arguments expected by the wrapped function.\n *\n * @param {(...args: A) => T} fn The function to wrap.\n * @returns {(...args: A) => Result<T>} A new function that returns a `Result` object.\n *\n * @example\n * function divideByTwo(num: number): number {\n *   if (num === 0) {\n *     throw new Error(\"Cannot divide zero\");\n *   }\n *   return num / 2;\n * }\n *\n * const wrappedDivideByTwo = wrapThrows(divideByTwo);\n *\n * const result1: Result<number> = wrappedDivideByTwo(10); // { ok: true, data: 5 }\n * const result2: Result<number> = wrappedDivideByTwo(0); // { ok: false, error: Error(\"Cannot divide zero\") }\n */\nexport const wrapThrows =\n  <T, A extends any[]>(fn: (...args: A) => T): ((...args: A) => Result<T>) =>\n  (...args: A): Result<T> => {\n    try {\n      return {\n        ok: true,\n        data: fn(...args),\n      };\n    } catch (error: any) {\n      return {\n        ok: false,\n        error,\n      };\n    }\n  };\n\nexport const wrapThrowsAsync =\n  <T, A extends any[]>(fn: (...args: A) => Promise<T>) =>\n  async (...args: A): Promise<Result<T>> => {\n    try {\n      return {\n        ok: true,\n        data: await fn(...args),\n      };\n    } catch (error) {\n      return {\n        ok: false,\n        error: error as Error,\n      };\n    }\n  };\n","// Simple queue for formbricks methods\n\nexport class MethodQueue {\n  private queue: (() => Promise<void>)[] = [];\n  private isExecuting = false;\n\n  add = (method: () => Promise<void>) => {\n    this.queue.push(method);\n    this.run();\n  };\n\n  private runNext = async () => {\n    if (this.isExecuting) return;\n\n    const method = this.queue.shift();\n    if (method) {\n      this.isExecuting = true;\n      try {\n        await method();\n      } finally {\n        this.isExecuting = false;\n        if (this.queue.length > 0) {\n          this.runNext();\n        }\n      }\n    }\n  };\n\n  run = async () => {\n    if (!this.isExecuting && this.queue.length > 0) {\n      await this.runNext();\n    }\n  };\n\n  clear = () => {\n    this.queue = [];\n  };\n}\n","import { Result, wrapThrowsAsync } from \"../../../types/errorHandlers\";\nimport { MethodQueue } from \"../methodQueue\";\n\nlet isInitializing = false;\nlet isInitialized = false;\nconst methodQueue = new MethodQueue();\n\n// Load the SDK, return the result\nconst loadFormbricksSDK = async (apiHost: string, sdkType: \"app\" | \"website\"): Promise<Result<void>> => {\n  if (!window.formbricks) {\n    const res = await fetch(`${apiHost}/api/packages/${sdkType}`);\n\n    // Failed to fetch the app package\n    if (!res.ok) {\n      return { ok: false, error: new Error(`Failed to load Formbricks ${sdkType} SDK`) };\n    }\n\n    const sdkScript = await res.text();\n    const scriptTag = document.createElement(\"script\");\n    scriptTag.innerHTML = sdkScript;\n    document.head.appendChild(scriptTag);\n\n    const getFormbricks = async () =>\n      new Promise<void>((resolve, reject) => {\n        const checkInterval = setInterval(() => {\n          if (window.formbricks) {\n            clearInterval(checkInterval);\n            resolve();\n          }\n        }, 100);\n\n        setTimeout(() => {\n          clearInterval(checkInterval);\n          reject(new Error(`Formbricks ${sdkType} SDK loading timed out`));\n        }, 10000);\n      });\n\n    try {\n      await getFormbricks();\n      return { ok: true, data: undefined };\n    } catch (error: any) {\n      return {\n        ok: false,\n        error: new Error(error.message ?? `Failed to load Formbricks ${sdkType} SDK`),\n      };\n    }\n  }\n\n  return { ok: true, data: undefined };\n};\n\n// TODO: @pandeymangg - Fix these types\n// type FormbricksAppMethods = {\n//   [K in keyof TFormbricksApp]: TFormbricksApp[K] extends Function ? K : never;\n// }[keyof TFormbricksApp];\n\n// type FormbricksWebsiteMethods = {\n//   [K in keyof TFormbricksWebsite]: TFormbricksWebsite[K] extends Function ? K : never;\n// }[keyof TFormbricksWebsite];\n\nexport const loadFormbricksToProxy = async (prop: string, sdkType: \"app\" | \"website\", ...args: any[]) => {\n  const executeMethod = async () => {\n    try {\n      //  @ts-expect-error\n      return await (window.formbricks[prop] as Function)(...args);\n    } catch (error) {\n      console.error(`ðŸ§± Formbricks - Global error: ${error}`);\n      throw error;\n    }\n  };\n\n  if (!isInitialized) {\n    if (isInitializing) {\n      methodQueue.add(executeMethod);\n    } else {\n      if (prop === \"init\") {\n        isInitializing = true;\n\n        const initialize = async () => {\n          const { apiHost } = args[0];\n          const loadSDKResult = await wrapThrowsAsync(loadFormbricksSDK)(apiHost, sdkType);\n\n          if (!loadSDKResult.ok) {\n            isInitializing = false;\n            console.error(`ðŸ§± Formbricks - Global error: ${loadSDKResult.error.message}`);\n            return;\n          }\n\n          try {\n            const result = await (window.formbricks[prop] as Function)(...args);\n            isInitialized = true;\n            isInitializing = false;\n\n            return result;\n          } catch (error) {\n            isInitializing = false;\n            console.error(`ðŸ§± Formbricks - Global error: ${error}`);\n            throw error;\n          }\n        };\n\n        methodQueue.add(initialize);\n      } else {\n        console.error(\n          \"ðŸ§± Formbricks - Global error: You need to call formbricks.init before calling any other method\"\n        );\n        return;\n      }\n    }\n  } else {\n    // @ts-expect-error\n    if (window.formbricks && typeof window.formbricks[prop] !== \"function\") {\n      console.error(\n        `ðŸ§± Formbricks - Global error: Formbricks ${sdkType} SDK does not support method ${String(prop)}`\n      );\n      return;\n    }\n\n    methodQueue.add(executeMethod);\n    return;\n  }\n};\n"],"names":[],"mappings":"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"}